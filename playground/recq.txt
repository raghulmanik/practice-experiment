ğŸ§© PHASE 1 â€” Core Accumulation Recursion (Sum/Product/Count)

Goal: solidify base-return unwinding logic

sumArray(n) â†’ return total sum

prodArray(n) â†’ return total product

countEven(n) â†’ count even numbers

countOdd(n) â†’ count odd numbers

countGreaterThanX(n, x) â†’ count numbers > x

findMax(n) â†’ return max element

findMin(n) â†’ return min element

ğŸ§© PHASE 2 â€” Printing vs Returning

Goal: understand â€œwhen code before/after recursion executesâ€

printForward(n) â†’ print elements in forward order

printBackward(n) â†’ print elements in reverse order

printEverySecond(n) â†’ print every 2nd element

printEvenIndex(n) â†’ print only even indices

printArrayIndices(n) â†’ print â€œindex â†’ valueâ€ pairs

ğŸ§© PHASE 3 â€” Dual-variable Recursion

Goal: handle left/right traversal patterns (foundation of 2-pointer + divide-and-conquer)

printBoth(i, j) â†’ print arr[i] and arr[j] moving inward

isPalindrome(i, j) â†’ check if array is palindrome

reverseArray(i, j) â†’ swap recursively

sumRange(i, j) â†’ sum elements between i and j

countPairs(i, j) â†’ count pairs whose sum == target

ğŸ§© PHASE 4 â€” Build Structures via Recursion

Goal: recursion that returns new arrays/strings

copyArray(n) â†’ return a copy recursively

reverseArrayReturn(n) â†’ return reversed array

filterEven(n) â†’ return new array of only evens

mapDouble(n) â†’ return array with all elements * 2

concatString(n) â†’ join all elements into a string recursively

ğŸ§© PHASE 5 â€” Recursive Logic Challenges

Goal: build pattern-recognition muscle (real recursion problems)

sumOfDigits(n) â†’ sum digits of a number

factorial(n) â†’ product of numbers 1â€¦n

fibonacci(n) â†’ nth Fibonacci

power(x, n) â†’ xâ¿ recursively

countZeros(n) â†’ count zeros in a number

sumNestedArray(arr) â†’ handle arrays inside arrays (deep recursion)

flattenArray(arr) â†’ flatten nested arrays recursively

binarySearchRec(arr, target, low, high) â†’ core recursion used in algorithms